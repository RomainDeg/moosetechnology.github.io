---
authors:
- CyrilFerlicot
title: "Testing your algo on a java project"
date:  2025-10-08
lastUpdated:  2025-10-08
tags:
- testing
---

## Introduction

When developping algorithm on top of the Moose platform, we can easily hurt a wall during testing.

To do functional (and sometimes unit) testing, we need to work on a Moose model. Most of the time we are getting this model in two ways:
- We produce a model and save the `.json` to recreate this model in the tests
- We create a model by hand

But those 2 solutions have drawbacks:
- Keeping a JSON will not follow the evolutions of Famix and the model produce will not be representative of the last version of Famix
- Creating a model by hand has the drawback of taking the risk that this model will not be representative of what we could manipulate in reality. For example, we might not think about setting the stubs or the source anchors

In order to avoid those drawbacks I will describe my way of managing such testing cases in this article. In order to do this, I will explain how I set up the tests of a project to build CallGraph of Java projects.

## The idea

The idea I had for testing callgraphs is to implement real java projects in a `resources` folder in the git of the project. Then, we can parse them when launching the tests and manipulate the produced model. This would ensure that we always have a model up to date with the latest version of Famix. If tests breaks, this means that our famix model evolved and that our project does not work anymore for this language.

![Process](./img/posts/2025-10-08-testing-your-algo-on-a-java-project/process.drawio.svg)

## Basic setup 

### Create your java code

The first step to build tests is to write some example java code.

I will start with a minimal example:

```java
public class Main {
    public static void main(String[] args) {

        System.out.println("Hello World!");
    }
}
```

I'll save this file in the git repository of my project under `Famix-CallGraph/resources/sources/example1/Main.java`.

Now that we have the source code, we need a way to access it in our project.

### Use GitBridge

In order to access our resources, we will use `GitBrigde` ([https://github.com/jecisc/GitBridge](https://github.com/jecisc/GitBridge)). 

You can install it by executing:

```smalltalk
    Metacello new
    	githubUser: 'jecisc' project: 'GitBridge' commitish: 'v1.x.x' path: 'src';
    	baseline: 'GitBridge';
    	load
```

But we should add it to our baseline:

```smalltalk
BaselineOfFamixCallGraph >> #gitBridge: spec

	spec baseline: 'GitBridge' with: [ spec repository: 'github://jecisc/GitBridge:v1.x.x/src' ]
```

```smalltalk
BaselineOfFamixCallGraph >> #baseline: spec

	<baseline>
	spec for: #common do: [
		"Dependencies"
		self gitBridge: spec.

		"Packages"
		spec
			package: 'Famix-CallGraph';
			package: 'Famix-CallGraph-Tests' with: [ spec requires: #( 'Famix-CallGraph' 'GitBridge' ) ]. "<== WE ADD GITBRIDGE HERE!"
		 ].

	spec for: #NeedsFamix do: [
		self famix: spec.

		spec package: 'Famix-CallGraph' with: [ spec requires: #( Famix ) ] ]
```

Now that we have the dependency running, we can use this project. (We will explain the minimal steps here but you can find the [full documantation here](https://github.com/jecisc/GitBridge/blob/master/resources/documentation/UserGuide.md))

The usage of GitBridge begins with the definition of our `FamixCallGraphBridge`:

```smalltalk
GitBridge << #FamixCallGraphBridge
	slots: {};
	package: 'Famix-CallGraph-Tests'
```

Now that this class exists we can access our git folder using `FamixCallGraphBridge current root`.

Let's add some syntactic suggar:

```smalltalk
FamixCallGraphBridge class >> #resources

	^ self root / 'resources'
```
```smalltalk
FamixCallGraphBridge class >> #sources

	^ self resources / 'sources'
```

We can now check our java projects doing `FamixCallGraphBridge current sources`.

This step is almost done, but in order for our tests to work in a github action (for example), we need two little tweaks.

In our `smalltalk.ston` file, we need to register our project in Iceberg (because GitBridge uses Iceberg to access the root folder).

```smalltalk
SmalltalkCISpec {
  #loading : [
    SCIMetacelloLoadSpec {
      #baseline : 'FamixCallGraph',
      #directory : 'src',
      #registerInIceberg : true   "<== This line"
    }
  ]
}
```

Also, in our github action we need to be sure that the checkout action will get enough info for git bridge to run and not the minimal ammount (which is the default) adding a `fetch-depth:` option.

```
steps:
  - uses: actions/checkout@v4
    with:
      fetch-depth: '0'
```

### Parse and import your model

Now we need to be able to parse our project. For this, we will use a Java utility thaht is directly in Moose: `FamixJavaFoldersImporter`.

We can parse and receive a model doing:

```smalltalk
model := (FamixJavaFoldersImporter importFolders: { FamixCallGraphBridge sources / 'example1' }) anyOne.
```


## Optimization


## Simplify your life


